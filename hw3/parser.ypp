%{
	#include "hw3_output.hpp"
	#include "Node.hpp"
	#include "symbol_table.hpp"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;
	using namespace output;

	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	int yyerror(const char * message);
%}

%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMENT;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%right ASSIGN;
%left OR;
%left AND;
%left LRELOP;
%left HRELOP;
%left PLUS MINUS;
%left MULT DEV;
%right NOT;
%left LPAREN RPAREN LBRACE RBRACE
%right IF;
%right ELSE;

%%

Program :{Symbol_Table sym=Symbol_Table();} Statements 		{output::printProductionRule(1);};


Statements : Statement 										{output::printProductionRule(2);};
| Statements Statement 										{output::printProductionRule(3);};


Statement : LBRACE NT Statements RBRACE 						{$$=$3;
																 sym.close_table();};
| Type ID SC 												{$$=new Node(yylineno,std::move($2->id))
															 $$->type=$1->type;
															 sym.insert_node($$);
															};
| Type ID ASSIGN Exp SC 									{$$=new exp($1,$2,$4,yylineno);
															 sym.insert_node($$);
															 };
| ID ASSIGN Exp SC 											{Entry *entry=sym.find_entry($1->text);
															 if(entry==nullptr || entry->is_func)
															 {
																errorUndef(yylineno,$1->text);
																exit(0);
															 }
															 $$=new Exp(entry->type,$1,$3,yylineno);
															 };
| Call SC 													{output::printProductionRule(8);};
| RETURN SC 												{output::printProductionRule(9);};
| IF LPAREN Exp RPAREN Statement 							{output::printProductionRule(10);};
| IF LPAREN Exp RPAREN Statement ELSE Statement 			{output::printProductionRule(11);};
| WHILE LPAREN Exp RPAREN Statement 						{output::printProductionRule(12);};
| BREAK SC 													{output::printProductionRule(13);};
| CONTINUE SC 												{output::printProductionRule(14);};


Call : ID LPAREN Exp RPAREN 								{output::printProductionRule(15);};


Type : INT 													{output::printProductionRule(16);};
| BYTE 														{output::printProductionRule(17);};
| BOOL 														{output::printProductionRule(18);};


Exp : LPAREN Exp RPAREN 									{$$=$1;};
| Exp PLUS Exp 												{$$=new Add($1,$3);};
| Exp MINUS Exp 											{$$=new Sub($1,$3)};
| Exp MULT Exp 												{$$=new Mul($1,$3)};
| Exp DEV Exp 												{$$=new Dev($1,$3)};
| ID 														{$$=$1;
															 Entry &entry = sym.find_entry($$->id);
															 if(entry == nullptr)
															 {
																errorUndef(yylineno,$$->id);
																exit(0);
															 }
															};

| Call 														{$$=$1};
| NUM 														{$$=$1};
| NUM B 													{if (atoi($1->text)>255){
																errorByteTooLarge(yylineno,$1->text);
																exit(0);}
																$$=new Byte(yylineno,$1->text);
																};

| STRING												 	{$$=$1;};
| TRUE 														{$$=$1;};
| FALSE 													{$$=$1;};
| NOT Exp 													{if ($2->type!=BOOL)
															 {errorMismatch(yylineno);
															  exit(0);}
															  $$=new Bool(yylineno,"");
															};

| Exp AND Exp 												{if($1->type!=BOOL || $3->type != BOOL){
															 	errorMismatch(yylineno);
															  	exit(0);}
															 $$=new Bool(yylineno,"");
															};

| Exp OR Exp									 			{if($1->type!=BOOL || $3->type != BOOL){
															 	errorMismatch(yylineno);
															  	exit(0);}
															 $$=new Bool(yylineno,"");
															 };

| Exp HRELOP Exp 											{if(!$1->is_num()||!$3->is_num()){
															 	errorMismatch(yylineno);
															  	exit(0);}
															$$=new Bool(yylineno,"");
															};

| Exp LRELOP Exp 											{if(!$1->is_num()||!$3->is_num()){
															 	errorMismatch(yylineno);
															  	exit(0);}
															$$=new Bool(yylineno,"");
															};

| LPAREN Type RPAREN Exp 									{$$=new Exp($2,$4);};    //cast


NT :                                                        {sym.open_table();} //NT-new table



%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(0);
}
