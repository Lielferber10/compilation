%{
	#include "hw3_output.hpp"
	#include "Node.hpp"
	#include "symbol_table.hpp"
	#include "bp.hpp"
	#include "utilities.hpp"
	#include <iostream>
	#include <stdlib.h>


	using namespace std;
	using namespace output;

	extern int yylex();
	extern char* yytext;
	extern int yylineno;
	int yyerror(const char * message);
	Symbol_Table sym = Symbol_Table();
	CodeBuffer codeBuffer = CodeBuffer();
	Var vars = Var();
	int nested_whiles = 0;
%}

%define parse.lac full

%nonassoc INT;
%nonassoc BYTE;
%nonassoc B;
%nonassoc BOOL;
%nonassoc TRUE;
%nonassoc FALSE;
%nonassoc RETURN;
%nonassoc WHILE;
%nonassoc BREAK;
%nonassoc CONTINUE;
%nonassoc SC;
%nonassoc COMMENT;
%nonassoc ID;
%nonassoc NUM;
%nonassoc STRING;
%right ASSIGN;
%left OR;
%left AND;
%left LRELOP;
%left HRELOP;
%left PLUS MINUS;
%left MULT DEV;
%right NOT;
%left LPAREN RPAREN LBRACE RBRACE
%right IF;
%right ELSE;

%%

Program : 
{
	init_llvm();

} Statements 
{
	codeBuffer.emit("ret i32 0");
	codeBuffer.emit("}");
	sym.close_table();
};


Statements : Statement 
{};

| Statements Statement 
{};


Statement : LBRACE NT Statements RBRACE 						{$$=$3; sym.close_table();};

| Type ID SC 
{
	$$ = new Node(yylineno, std::move($2->text), $1->type);
	sym.insert_node($$);
	if($1->type == TINT || $1->type == TBYTE)
	{
		$$->var = "0";
	}
	else if($1->type == TBOOL)
	{
		$$->var = "false";
	}
};

| Type ID ASSIGN Exp SC	
{
	Entry *entry=sym.find_entry($2->text);
	if(entry != nullptr)
	{
		errorDef(yylineno, $2->text);
		exit(0);
	}
	$2->type = $1->type;
	$$ = new Exp($1,$2,$4,yylineno); sym.insert_node($$);
	$$->var = $4->var;
	Entry* entry = find_entry($$->text);
	codeBuffer.emit("%address = getelementptr [50 x i32], [50 x i32]* %stack, i32 0, i32 " + std::to_string(entry->offset));
	if($$->type == TBOOL)
	{
		codeBuffer.emit("%value = zext i1 " + $$->var + " to i32");
		codeBuffer.emit("store i32 %value, i32* %address);
	}
	else if($$->type == TBYTE)
	{
		codeBuffer.emit("%value = zext i8 " + $$->var + " to i32");
		codeBuffer.emit("store i32 %value, i32* %address);
	}
	else if($$->type == TINT)
	{
		codeBuffer.emit("store i32 " + $$->var + ", i32* %address);
	}
};

| ID ASSIGN Exp SC 
{
	Entry *entry=sym.find_entry($1->text);
	if(entry==nullptr || entry->is_func)
	{
		errorUndef(yylineno,$1->text);
		exit(0);
	}
	$1 = new Node(yylineno, entry->id, entry->ret_type);
	if($1->type == $3->type || ($1->type == TINT && $3->type == TBYTE))
	{
		$$=new Exp(entry->ret_type,$1,$3,yylineno);
		codeBuffer.emit("%address = getelementptr [50 x i32], [50 x i32]* %stack, i32 0, i32 " + std::to_string(entry->offset));
		if($$->type == TBOOL)
		{
			codeBuffer.emit("%value = zext i1 " + $$->var + " to i32");
			codeBuffer.emit("store i32 %value, i32* %address);
		}
		else if($$->type == TBYTE)
		{
			codeBuffer.emit("%value = zext i8 " + $$->var + " to i32");
			codeBuffer.emit("store i32 %value, i32* %address);
		}
		else if($$->type == TINT)
		{
			codeBuffer.emit("store i32 " + $$->var + ", i32* %address);
		}
	}
	else
	{
		errorMismatch(yylineno);
		exit(0);
	}
	
};

| Call SC
{$$=$1;};

| RETURN SC 												
{};

| IF NT LPAREN Exp CB RPAREN Statement 
{sym.close_table();};

| IF NT LPAREN Exp CB RPAREN Statement N ELSE {sym.close_table();} NT Statement 
{sym.close_table();};

| WHILE NT LPAREN Exp 	
{
	if($4->type != TBOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
	nested_whiles++;

} RPAREN Statement {sym.close_table(); nested_whiles--;};

| BREAK SC 
{
	if(nested_whiles == 0)
	{
		errorUnexpectedBreak(yylineno);
		exit(0);
	}
};

| CONTINUE SC 
{
	if(nested_whiles == 0)
	{
		errorUnexpectedContinue(yylineno);
		exit(0);
	}
};

Call : ID LPAREN Exp RPAREN 
{
	Entry *entry = sym.find_entry($1->text);
	if(entry==nullptr || !entry->is_func)
	{
		errorUndefFunc(yylineno,$1->text);
		exit(0);
	}
	$1 = new Node(yylineno, entry->id, entry->ret_type);
	if($3->type == entry->func_types.at(0) || $3->type == TBYTE && (entry->id == "printi" || entry->id == "readi"))
	{
		$$ = new Node(yylineno, "", entry->ret_type);
	}
	else
	{
		errorPrototypeMismatch(yylineno, entry->id, type_to_string(entry->func_types.at(0)));
		exit(0);
	}
};

Type : INT 	
{$$ = $1;};

| BYTE 
{$$ = $1;};

| BOOL 
{$$ = $1;};


Exp : LPAREN Exp RPAREN 									{$$=$2;};

| Exp PLUS Exp 												
{
	$$=new Add($1,$3);
	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = add i32 " + $1->var + ", i32 " + $3->var);
	}
	else if($1->type == TBYTE && $3->type == TBYTE)
	{
		string value1 = vars.freshVar();
		string value2 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = add i32 " + value1 + ", i32 " + value2);
	}
	else if($1->type == TBYTE && $3->type == TINT)
	{
		string value1 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit($$->var + " = add i32 " + value1 + ", i32 " + $3->var);
	}
	else if($1->type == TINT && $3->type == TBYTE)
	{
		string value2 = vars.freshVar();
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = add i32 " + $3->var + ", i32 " + value2);
	}
	
};

| Exp MINUS Exp 											
{
	$$=new Sub($1,$3);
	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = sub i32 " + $1->var + ", i32 " + $3->var);
	}
	else if($1->type == TBYTE && $3->type == TBYTE)
	{
		string value1 = vars.freshVar();
		string value2 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sub i32 " + value1 + ", i32 " + value2);
	}
	else if($1->type == TBYTE && $3->type == TINT)
	{
		string value1 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit($$->var + " = sub i32 " + value1 + ", i32 " + $3->var);
	}
	else if($1->type == TINT && $3->type == TBYTE)
	{
		string value2 = vars.freshVar();
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sub i32 " + $3->var + ", i32 " + value2);
	}
};

| Exp MULT Exp 												
{
	$$=new Mul($1,$3);
	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = mul i32 " + $1->var + ", i32 " + $3->var);
	}
	else if($1->type == TBYTE && $3->type == TBYTE)
	{
		string value1 = vars.freshVar();
		string value2 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = mul i32 " + value1 + ", i32 " + value2);
	}
	else if($1->type == TBYTE && $3->type == TINT)
	{
		string value1 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit($$->var + " = mul i32 " + value1 + ", i32 " + $3->var);
	}
	else if($1->type == TINT && $3->type == TBYTE)
	{
		string value2 = vars.freshVar();
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = mul i32 " + $3->var + ", i32 " + value2);
	}
};

| Exp DEV Exp 												
{
	$$=new Dev($1,$3);
	if(%3->var == "0")
	{
		codeBuffer.emit("call void @print(i8* "Error division by zero");
		exit(0);
	}

	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = sdiv i32 " + $1->var + ", i32 " + $3->var);
	}
	else if($1->type == TBYTE && $3->type == TBYTE)
	{
		string value1 = vars.freshVar();
		string value2 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + value1 + ", i32 " + value2);
	}
	else if($1->type == TBYTE && $3->type == TINT)
	{
		string value1 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + value1 + ", i32 " + $3->var);
	}
	else if($1->type == TINT && $3->type == TBYTE)
	{
		string value2 = vars.freshVar();
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + $3->var + ", i32 " + value2);
	}
};

| ID 
{
	Entry* entry = sym.find_entry($1->text);
	if(entry == nullptr || entry->is_func)
	{
		errorUndef(yylineno,$1->text);
		exit(0);
	}
	$$ = new Node(yylineno, entry->id, entry->ret_type);
	$$->var = $1->var;
};

| Call 														{$$=$1;};

| NUM 														{$$=$1; $$->var = $1->text;};

| NUM B 
{
	const char* c = $1->text.c_str();
	if (atoi(c)>255)
	{
		errorByteTooLarge(yylineno,$1->text);
		exit(0);
	}
	$$=new Byte(yylineno,$1->text);
	$$->var = $1->text;
};

| STRING												 	{$$=$1; $$->var = $1->text;};

| TRUE 														{$$=$1; $$->var = $1->text;};

| FALSE 													{$$=$1; $$->var = $1->text;};

| NOT Exp 
{
	if ($2->type!=TBOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
	$$=new Bool(yylineno,"");

	if($2->var == "true")
	{
		$$->var = "false";
	}
	else if($2->var == "false")
	{
		$$->var = "true";
	}
};

| Exp AND Exp
{
	if($1->type!=TBOOL || $3->type != TBOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
	$$=new Bool(yylineno,"");

	if($1->var == "false")
	{
		$$->var = "false";
	}
	else if($1->var == "true" && $3->var == "false")
	{
		$$->var = "false";
	}
	else if($1->var == "true" && $3->var == "true")
	{
		$$->var = "true";
	}
};

| Exp OR Exp
{
	if($1->type!=TBOOL || $3->type != TBOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
	$$=new Bool(yylineno,"");

	if($1->val == "true")
	{
		$$->val = "true";
	}
	else if($1->val == "false" && $3->val == "true")
	{
		$$->val = "true";
	}
	else if($1->val == "false" && $3->val == "false")
	{
		$$->val = "false";
	}
	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = or i32 " + $1->var + ", i32 " + $3->var);
};

| Exp HRELOP Exp 
{
	if(!$1->is_num()||!$3->is_num())
	{
		errorMismatch(yylineno);
		exit(0);
	}
	$$=new Bool(yylineno,"");

	$$->var = vars.freshVar();
	if($1->type == TINT && $3->type == TINT)
	{
		codeBuffer.emit($$->var + " = sdiv i32 " + $1->var + ", i32 " + $3->var);
	}
	else if($1->type == TBYTE && $3->type == TBYTE)
	{
		string value1 = vars.freshVar();
		string value2 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + value1 + ", i32 " + value2);
	}
	else if($1->type == TBYTE && $3->type == TINT)
	{
		string value1 = vars.freshVar();
		codeBuffer.emit(value1 + " = zext i8 " + $1->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + value1 + ", i32 " + $3->var);
	}
	else if($1->type == TINT && $3->type == TBYTE)
	{
		string value2 = vars.freshVar();
		codeBuffer.emit(value2 + " = zext i8 " + $3->var + " to i32");
		codeBuffer.emit($$->var + " = sdiv i32 " + $3->var + ", i32 " + value2);
	}
};

| Exp LRELOP Exp
{
	if(!$1->is_num()||!$3->is_num())
	{
		errorMismatch(yylineno);
		exit(0);
	}
	$$=new Bool(yylineno,"");
};

| LPAREN Type RPAREN Exp 									{$$=new Exp($2,$4, yylineno);};    //cast

NT : 
{sym.open_table();} //NT-new table

CB : 
{
	if($0->type != TBOOL)
	{
		errorMismatch(yylineno);
		exit(0);
	}
	codeBuffer.emit($4->true_label + ":");
} //CB-check bool

N :
{
	$0->next_label=codeBuffer.freshLabel();
	codeBuffer.emit("goto " + $0.next_label);
}

%%

int main()
{
	yyparse();
	codeBuffer.printGlobalBuffer();
    codeBuffer.printCodeBuffer();
}

int yyerror(const char * message)
{
	errorSyn(yylineno);
	exit(0);
}
